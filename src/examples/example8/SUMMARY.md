# 微前端的又一次探索

1.npm

优点： 开发方式相对友好，宿主应用以require/import的方式加载子应用，子应用只需暴露统一接口供以调用即可，对子应用的技术栈没有限制；

缺点：编译时耦合，子应用更新发布后宿主应用需要被迫升级依赖，无法做到独立部署；由于不限定子应用的技术栈，因此一般只能简单的去渲染子应用，宿主与子应用交互难度比较高。

2.iframe

优点：方便快捷，几乎没有任何限制

缺点：只能满足很单一的需求，除了渲染子应用，交互的难度比npm方式还要高

3.mount/unmount DOM

优点：与npm方式类似，但是不需要以require/import的方式显式导入

缺点：对子应用的要求较高，子应用需要提供供多的方法让宿主对其进行管理，交互上比前两者会好一点

它的基本思路具体如下：

1.子应用(Child)有自己单独的repo,打包部署也是独立的
2.Child需要在入口处暴露自己的生命周期函数，至少需要：bootstrap, mount, unmount
2.Child打包后必须将自己的`asset-mainfest.json`暴露出来（里面包含了Child入口的bundle文件地址），里面的文件也必然是可被宿主(Host)访问的
3.Host监听路由，发现需要加载Child时动态请求Child的mainfest并且将Child挂载到一个新的dom节点上（一般此处会有缓存，防止re-mount）

这种方式其实是目前很多微前端的主流解决方案，基本上可以满足大部分的拆分和业务需求，老马之前在自己的博客里推荐的微前端的方案也如出一辙。

但如果你仔细观察第2步你会发现，这完全一个过程化的方式，再加上第3步是挂载到一个新的节点，以React作为参考，这里该怎么做呢？肯定是Child里会在mount里有如下实现：

```
export const mount = container => render(<SubAppEntry />, container);
```

如此一来，Child就和Host在逻辑和数据层面脱离了，当然了，你要是真愿意，你也可以让Child暴露更多更多的方法来让Host去管理自己（而不仅限于生命周期的钩子），倒也不是不行，可你真要是有十几个Child那工作量和维护难度可不是一般，这就是为什么我在缺点一项中说它比npm和iframe稍好，但是依然还是个缺点的原因。但还是那就话，如果你的Child真的没啥和Host交互的，此方案还是首选的（毕竟钩子函数是你自己写的呀，完全没有技术栈限制）

4.动态注入

优点：独立部署，独立开发，可与Host无缝交互，可满兼容上述三种方案
缺点：技术栈需要统一

注意，方案3可不是动态注入，是动态挂载，区别在于你加载的Child在逻辑和数据层面上是不是属于Host，显然方案3是独立的。所以此方案的主要是的方案3的基础上做如下调整(以React为例)：

1.子应用(Child)有自己单独的repo,打包部署也是独立的
2.~~Child需要在入口处暴露自己的生命周期函数，至少需要：bootstrap, mount, unmount~~
Child不需要提供生命周期的钩子，只需要在入口处暴露自己的配置信息，如自己的reducers/store/routers...
2.Child打包后必须将自己的`asset-mainfest.json`暴露出来（里面包含了Child入口的bundle文件地址），里面的文件也必然是可被宿主(Host)访问的
3.Host监听路由，发现需要加载Child时动态请求Child的mainfest并且将~~Child挂载到一个新的dom节点上（一般此处会有缓存，防止re-mount~~
此处就是不挂载了，而是自己请求Child暴露出来的组件，这样天然的将Child和Host融为一体，你可以把Host的store传递给Child，更可以把Child里的reducer动态的注入的全局，当然你甚至可以把它当作方案3来用（即Child有自己的store，Host注入进来就不管了，就当它是一个简单的Component而已）

读到这里，可能有一些细节需要解释，比如：
1.这怎么听起来像是我们正常的开发方式呀，即一个project下有多个业务模块的folder,每个folder的index不就是所谓的Child的入口组件么，这本来就是一个应用呀，自然技术栈也是一样的，这怎么就微前端了？
2.方案3里我们可以在全局变量（如window）上注入Child的生命周期函数，以此供Host调用，那这种方案里是如何远程请求一个组件的bundle文件并且注入到一个已经存在的React环境里呢（Host打包里的React实例必然和Child里的React实例不一致，就算版本一致也不一样）,这里有啥坑呢？


TODO: complete the this readme